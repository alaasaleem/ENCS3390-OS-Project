#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#define MAX_NAME_LENGTH 10
#define MAX_PROCESSES 100
// Structure to represent a process
struct Process {
    char name[MAX_NAME_LENGTH];
    int arrivalTime;
    int burstTime;
    int remainingTime;
    int completionTime;
    int turnaroundTime;
    int waitingTime;
    int priority;
    int responseTime;
    int startTime;
};
// Structure to represent a task queue
struct TaskQueue {
    struct Process processes[MAX_PROCESSES];
    int front;
    int rear;
    int size;
};

// Structure to represent a Gantt chart entry
struct GanttEntry {
    char processName[10];
    int executionTime;
};
int numOfAddedProcesses = 0;

struct TaskQueue originalTaskQueue;


// Function prototypes
void enqueue(struct TaskQueue* queue, struct Process process);
void sjfScheduling(struct TaskQueue* taskQueue);
void roundRobinScheduling(struct TaskQueue* taskQueue, int timeQuantum);
void prioritySchedulingWithoutPreemption(struct TaskQueue* taskQueue);
void prioritySchedulingWithPreemption(struct TaskQueue* taskQueue);
void printProcessTable(struct TaskQueue* taskQueue);
void printMetricsTable(struct TaskQueue* taskQueue);
void removeProcess(struct TaskQueue* queue, char* processName);
void clearInputBuffer();
int min(int a, int b);
void initializeOriginalTaskQueue(struct TaskQueue* taskQueue);

//remove process
void removeProcess(struct TaskQueue* queue, char* processName) {
    int found = 0;
    for (int i = queue->front; i <= queue->rear; i++) {
        if (strcmp(queue->processes[i].name, processName) == 0) {
            found = 1;
            // Shift the remaining processes to the left
            for (int j = i; j < queue->rear; j++) {
                queue->processes[j] = queue->processes[j + 1];
            }
            queue->rear--;
            queue->size--;
            break;
        }
    }
    if (found) {
        printf("Process '%s' removed successfully.\n", processName);
    } else {
        printf("Process '%s' not found in the task queue.\n", processName);
    }
}
// Enqueues a process into the task queue
void enqueue(struct TaskQueue* queue, struct Process process) {
    if (queue->rear == MAX_PROCESSES - 1) {
        printf("Queue is full. Cannot enqueue more tasks.\n");
        return;
    }
    // Increase the rear index and add the process to the queue
    queue->rear++;
    queue->processes[queue->rear] = process;
    queue->size++;
}
// Finds the minimum of two numbers
int min(int a, int b) {
    return (a < b) ? a : b;
}
// Performs round-robin scheduling on the task queue with a given time quantum
void roundRobinScheduling(struct TaskQueue* taskQueue, int timeQuantum) {
    int currentTime = 0;
    int completedProcesses = 0;

    // Create a Gantt chart array to store process names, start times, and execution times
    struct GanttEntry {
        char processName[10];
        int startTime;
        int executionTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES * 100];  // Assuming maximum 100 time slots per process
    int ganttIndex = 0;  // Index to keep track of the Gantt chart entries

    while (completedProcesses < taskQueue->size) {
        int i = taskQueue->front;
        while (i <= taskQueue->rear) {
            struct Process* process = &taskQueue->processes[i];
            if (process->remainingTime > 0) {
                int executionTime = (process->remainingTime > timeQuantum) ? timeQuantum : process->remainingTime;
                process->remainingTime -= executionTime;
                currentTime += executionTime;

                // Store the Gantt chart entry
                strcpy(ganttChart[ganttIndex].processName, process->name);
                ganttChart[ganttIndex].startTime = currentTime - executionTime;
                ganttChart[ganttIndex].executionTime = executionTime;
                ganttIndex++;

                // Print the execution order
                if (process->arrivalTime <= currentTime - executionTime) {
                    if (process->remainingTime == 0) {
                        printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", ganttChart[ganttIndex - 1].startTime, currentTime, process->name);
                    } else {
                        printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", ganttChart[ganttIndex - 1].startTime, currentTime, process->name, process->remainingTime);
                    }
                }

                // Process completed
                if (process->remainingTime == 0) {
                    process->completionTime = currentTime;
                    process->turnaroundTime = process->completionTime - process->arrivalTime;
                    process->waitingTime = process->turnaroundTime - process->burstTime;
                    completedProcesses++;
                }
            }
            i = (i + 1) % MAX_PROCESSES;  // Circularly traverse the queue
        }
    }

    // Set the start time for each process based on the first appearance in the Gantt chart
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];
        for (int j = 0; j < ganttIndex; j++) {
            if (strcmp(process->name, ganttChart[j].processName) == 0) {
                process->startTime = ganttChart[j].startTime;
                break;
            }
        }
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------------------------------------------------------------------\n");
    for (int i = 0; i < ganttIndex; i++) {
        printf("| %s ", ganttChart[i].processName);
    }
    printf("|\n");
    printf("----------------------------------------------------------------------\n");
    printf("0");
    int cumulativeTime = 0;
    for (int i = 0; i < ganttIndex; i++) {
        cumulativeTime += ganttChart[i].executionTime;
        printf("------%d", cumulativeTime);
    }
    printf("\n");

    // Print the process table and metrics table
    printProcessTable(taskQueue);
    printMetricsTable(taskQueue);
}



// Performs FCFS scheduling on the task queue
void fcfsScheduling(struct TaskQueue* taskQueue) {
    // Sort the tasks based on arrival time in FCFS manner
    for (int i = 0; i < taskQueue->size - 1; i++) {
        for (int j = 0; j < taskQueue->size - i - 1; j++) {
            if (taskQueue->processes[j].arrivalTime > taskQueue->processes[j + 1].arrivalTime) {
                // Swap the processes if the current process has a higher arrival time than the next process
                struct Process temp = taskQueue->processes[j];
                taskQueue->processes[j] = taskQueue->processes[j + 1];
                taskQueue->processes[j + 1] = temp;
            }
        }
    }

    int currentTime = 0;
    printf("The order in which processes or threads are selected for execution:\n");
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];
        // Set the startTime
        process->startTime = currentTime;
        // Calculate waiting time
        process->waitingTime = currentTime - process->arrivalTime;
        if (process->waitingTime < 0)
            process->waitingTime = 0;
        // Calculate completion time and turnaround time
        process->completionTime = currentTime + process->burstTime;
        process->turnaroundTime = process->completionTime - process->arrivalTime;
        currentTime = process->completionTime;
        // Print the execution order
        if (process->burstTime == 0) {
            printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", currentTime - process->burstTime, currentTime, process->name);
        }
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------------------------------------------------------------------\n");
    printf("|");
    for (int i = 0; i < taskQueue->size; i++) {
        printf(" %s |", taskQueue->processes[i].name);
    }
    printf("\n");
    printf("---------------------------------------------------------------------\n");
    printf("0");
    int cumulativeTime = 0;
    for (int i = 0; i < taskQueue->size; i++) {
        cumulativeTime += taskQueue->processes[i].burstTime;
        printf("------%d", cumulativeTime);
    }
    printf("\n");

    // Print the process table and metrics table
    printProcessTable(taskQueue);
    printMetricsTable(taskQueue);
}

// Performs SJF scheduling on the task queue (preemptive)
void sjfPreemptiveScheduling(struct TaskQueue* taskQueue) {
    // Sort the tasks based on arrival time in FCFS manner
    for (int i = 0; i < taskQueue->size - 1; i++) {
        for (int j = 0; j < taskQueue->size - i - 1; j++) {
            if (taskQueue->processes[j].arrivalTime > taskQueue->processes[j + 1].arrivalTime) {
                // Swap the processes if the current process has a higher arrival time than the next process
                struct Process temp = taskQueue->processes[j];
                taskQueue->processes[j] = taskQueue->processes[j + 1];
                taskQueue->processes[j + 1] = temp;
            }
        }
    }

    int currentTime = 0;
    int completedProcesses = 0;

    // Create a Gantt chart array to store process names, start times, and end times
    struct GanttEntry {
        char processName[10];
        int startTime;
        int endTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES];
    int ganttIndex = 0;  // Index to keep track of the Gantt chart entries

    printf("The order in which processes or threads are selected for execution:\n");
    while (completedProcesses < taskQueue->size) {
        int shortestJobIndex = -1;
        int shortestJobRemainingTime = -1;
        for (int i = 0; i < taskQueue->size; i++) {
            struct Process* process = &taskQueue->processes[i];
            if (process->arrivalTime <= currentTime && process->remainingTime > 0) {
                if (shortestJobIndex == -1 || process->remainingTime < shortestJobRemainingTime) {
                    shortestJobIndex = i;
                    shortestJobRemainingTime = process->remainingTime;
                }
            }
        }

        if (shortestJobIndex != -1) {
            struct Process* process = &taskQueue->processes[shortestJobIndex];
            int executionTime = 1;
            process->remainingTime -= executionTime;
            currentTime += executionTime;

            // Store the Gantt chart entry
            if (ganttIndex > 0 && strcmp(ganttChart[ganttIndex - 1].processName, process->name) == 0) {
                ganttChart[ganttIndex - 1].endTime = currentTime;
            } else {
                strcpy(ganttChart[ganttIndex].processName, process->name);

                // Set the start time as the current time if it's the first allocation for the process
                if (ganttIndex == 0 || strcmp(ganttChart[ganttIndex - 1].processName, process->name) != 0) {
                    ganttChart[ganttIndex].startTime = currentTime - 1;
                }

                ganttChart[ganttIndex].endTime = currentTime;
                ganttIndex++;
            }

            // Print the execution order
            if (process->remainingTime == 0) {
                printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", ganttChart[ganttIndex - 1].startTime, currentTime, process->name);
            } else {
                printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", ganttChart[ganttIndex - 1].startTime, currentTime, process->name, process->remainingTime);
            }

            // Process completed
            if (process->remainingTime == 0) {
                process->completionTime = currentTime;
                process->turnaroundTime = process->completionTime - process->arrivalTime;
                process->waitingTime = process->turnaroundTime - process->burstTime;
                completedProcesses++;
            }
        } else {
            currentTime++;
        }
    }

    // Set the start time for each process based on the first appearance in the Gantt chart
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];
        for (int j = 0; j < ganttIndex; j++) {
            if (strcmp(process->name, ganttChart[j].processName) == 0) {
                process->startTime = ganttChart[j].startTime;
                break;
            }
        }
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------------------------------------------------------------------\n");
    printf("| ");
    for (int i = 0; i < ganttIndex; i++) {
        printf("%s ", ganttChart[i].processName);
        if (i < ganttIndex - 1) {
            printf("| ");
        }
    }
    printf("|\n");
    printf("---------------------------------------------------------------------\n");
    printf("0");
    for (int i = 0; i < ganttIndex; i++) {
        printf("------%d", ganttChart[i].endTime);
    }
    printf("\n");

    // Print the process table and metrics table
    printProcessTable(taskQueue);
    printMetricsTable(taskQueue);
}

// Performs SJF scheduling on the task queue (non-preemptive)
void sjfNonPreemptiveScheduling(struct TaskQueue* taskQueue) {
    // Sort the tasks based on arrival time in FCFS manner
    for (int i = 0; i < taskQueue->size - 1; i++) {
        for (int j = 0; j < taskQueue->size - i - 1; j++) {
            if (taskQueue->processes[j].arrivalTime > taskQueue->processes[j + 1].arrivalTime) {
                // Swap the processes if the current process has a higher arrival time than the next process
                struct Process temp = taskQueue->processes[j];
                taskQueue->processes[j] = taskQueue->processes[j + 1];
                taskQueue->processes[j + 1] = temp;
            }
        }
    }

    int currentTime = 0;
    int completedProcesses = 0;

    // Create a Gantt chart array to store process names, start times, and end times
    struct GanttEntry {
        char processName[10];
        int startTime;
        int endTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES];
    int ganttIndex = 0;  // Index to keep track of the Gantt chart entries

    printf("The order in which processes or threads are selected for execution:\n");
    while (completedProcesses < taskQueue->size) {
        int shortestJobIndex = -1;
        int shortestJobRemainingTime = -1;
        for (int i = 0; i < taskQueue->size; i++) {
            struct Process* process = &taskQueue->processes[i];
            if (process->arrivalTime <= currentTime && process->remainingTime > 0) {
                if (shortestJobIndex == -1 || process->remainingTime < shortestJobRemainingTime) {
                    shortestJobIndex = i;
                    shortestJobRemainingTime = process->remainingTime;
                }
            }
        }

        if (shortestJobIndex != -1) {
            struct Process* process = &taskQueue->processes[shortestJobIndex];
            int executionTime = process->remainingTime;
            process->remainingTime -= executionTime;
            currentTime += executionTime;

            // Store the Gantt chart entry
            if (ganttIndex > 0 && strcmp(ganttChart[ganttIndex - 1].processName, process->name) == 0) {
                ganttChart[ganttIndex - 1].endTime = currentTime;
            } else {
                strcpy(ganttChart[ganttIndex].processName, process->name);

                // Set the start time as the current time if it's the first allocation for the process
                if (ganttIndex == 0 || strcmp(ganttChart[ganttIndex - 1].processName, process->name) != 0) {
                    ganttChart[ganttIndex].startTime = currentTime - 1;
                }

                ganttChart[ganttIndex].endTime = currentTime;
                ganttIndex++;
            }

            // Print the execution order
            if (process->remainingTime == 0) {
                printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", ganttChart[ganttIndex - 1].startTime, currentTime, process->name);
            } else {
                printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", ganttChart[ganttIndex - 1].startTime, currentTime, process->name, process->remainingTime);
            }

            // Process completed
            if (process->remainingTime == 0) {
                process->completionTime = currentTime;
                process->turnaroundTime = process->completionTime - process->arrivalTime;
                process->waitingTime = process->turnaroundTime - process->burstTime;
                completedProcesses++;
            }
        } else {
            currentTime++;
        }
    }

    // Set the start time for each process based on the first appearance in the Gantt chart
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];
        for (int j = 0; j < ganttIndex; j++) {
            if (strcmp(process->name, ganttChart[j].processName) == 0) {
                process->startTime = ganttChart[j].startTime;
                break;
            }
        }
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------------------------------------------------------------------\n");
    printf("| ");
    for (int i = 0; i < ganttIndex; i++) {
        printf("%s ", ganttChart[i].processName);
        if (i < ganttIndex - 1) {
            printf("| ");
        }
    }
    printf("|\n");
    printf("---------------------------------------------------------------------\n");
    printf("0");
    for (int i = 0; i < ganttIndex; i++) {
        printf("------%d", ganttChart[i].endTime);
    }
    printf("\n");

    // Print the process table and metrics table
    printProcessTable(taskQueue);
    printMetricsTable(taskQueue);
}

// Prints the process table
void printProcessTable(struct TaskQueue* taskQueue) {
    printf("\nProcess Table:\n");
    printf("+-------+-----------------+------------------+--------------+\n");
    printf("| Name  | Arrival Time    | Burst Time       | Priority     |\n");
    printf("|       |                 |                  |              |\n");
    printf("+-------+-----------------+------------------+--------------+\n");
    for (int i = taskQueue->front; i <= taskQueue->rear; i++) {
        printf("| %-5s | %-15d | %-16d | %-12d |\n",
               taskQueue->processes[i].name, taskQueue->processes[i].arrivalTime,
               taskQueue->processes[i].burstTime, taskQueue->processes[i].priority);
    }
    printf("+-------+-----------------+------------------+--------------+\n");
}

// Helper function to calculate and print the metrics table
void printMetricsTable(struct TaskQueue* taskQueue) {
    printf("\nMetrics Table:\n");
    printf("---------------------------------------------------------------------------------\n");
    printf("| Process Id | Completion Time | Turnaround Time | Waiting Time | Response Time |\n");
    printf("---------------------------------------------------------------------------------\n");
    for (int i = taskQueue->front; i <= taskQueue->rear; i++) {
        struct Process* process = &taskQueue->processes[i];
        process->waitingTime = process->turnaroundTime - process->burstTime;

        // Calculate the response time as the first allocation to CPU minus the arrival time
        int responseTime = process->startTime - process->arrivalTime;

        printf("| %11s | %15d | %15d | %12d | %13d - %d = %d|\n", process->name, process->completionTime, process->turnaroundTime, process->waitingTime, process->startTime, process-> arrivalTime, responseTime);
    }
    printf("----------------------------------------------------------------------------------------------------\n");
}

// Performs priority scheduling on the task queue with preemption
void prioritySchedulingWithPreemption(struct TaskQueue* taskQueue) {
    int currentTime = 0;
    int completedProcesses = 0;
    int timeQuantum = 1;
    // Create a Gantt chart array to store process names, start times, and end times
    struct GanttEntry {
        char processName[10];
        int startTime;
        int endTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES];
    int ganttIndex = 0;  // Index to keep track of the Gantt chart entries


    printf("\nThe order in which processes or threads are selected for execution:\n");
    while (completedProcesses < taskQueue->size) {
        int i = taskQueue->front;
        int highestPriority = INT_MAX;
        int selectedProcessIndex = -1;
        while (i <= taskQueue->rear) {
            struct Process* process = &taskQueue->processes[i];
            if (process->remainingTime > 0 && process->priority < highestPriority && process->arrivalTime <= currentTime) {
                highestPriority = process->priority;
                selectedProcessIndex = i;
            }
            i = (i + 1) % MAX_PROCESSES;
        }
        if (selectedProcessIndex != -1) {
            struct Process* process = &taskQueue->processes[selectedProcessIndex];
            int executionTime = min(process->remainingTime, timeQuantum);
            process->remainingTime -= executionTime;
            currentTime += executionTime;

            // Store the Gantt chart entry
            if (ganttIndex > 0 && strcmp(ganttChart[ganttIndex - 1].processName, process->name) == 0) {
                ganttChart[ganttIndex - 1].endTime = currentTime;
            } else {
                strcpy(ganttChart[ganttIndex].processName, process->name);

                // Set the start time as the current time if it's the first allocation for the process
                if (ganttIndex == 0 || strcmp(ganttChart[ganttIndex - 1].processName, process->name) != 0) {
                    ganttChart[ganttIndex].startTime = currentTime - 1;
                }

                ganttChart[ganttIndex].endTime = currentTime;
                ganttIndex++;
            }

            // Print the execution order
            if (process->remainingTime == 0) {
                printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", ganttChart[ganttIndex - 1].startTime, currentTime, process->name);
            } else {
                printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", ganttChart[ganttIndex - 1].startTime, currentTime, process->name, process->remainingTime);
            }

            // Process completed
            if (process->remainingTime == 0) {
                process->completionTime = currentTime;
                process->turnaroundTime = process->completionTime - process->arrivalTime;
                process->waitingTime = process->turnaroundTime - process->burstTime;
                completedProcesses++;
            }
        } else {
            currentTime++;
        }
    }
    // Set the start time for each process based on the first appearance in the Gantt chart
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];
        for (int j = 0; j < ganttIndex; j++) {
            if (strcmp(process->name, ganttChart[j].processName) == 0) {
                process->startTime = ganttChart[j].startTime;
                break;
            }
        }
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------------------------------------------------------------------\n");
    printf("| ");
    for (int i = 0; i < ganttIndex; i++) {
        printf("%s ", ganttChart[i].processName);
        if (i < ganttIndex - 1) {
            printf("| ");
        }
    }
    printf("|\n");
    printf("---------------------------------------------------------------------\n");
    printf("0");
    for (int i = 0; i < ganttIndex; i++) {
        printf("------%d", ganttChart[i].endTime);
    }
    printf("\n");

    // Print the process table and metrics table
    printProcessTable(taskQueue);
    printMetricsTable(taskQueue);
}

//Performs priority scheduling on the task queue with non preemption
void prioritySchedulingWithoutPreemption(struct TaskQueue* taskQueue) {
    int currentTime = 0;
    int completedProcesses = 0;
    int timeQuantum = 1;
    // Create a Gantt chart array to store process names, start times, and end times
    struct GanttEntry {
        char processName[10];
        int startTime;
        int endTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES];
    int ganttIndex = 0;  // Index to keep track of the Gantt chart entries

    printf("\nThe order in which processes or threads are selected for execution:\n");
    while (completedProcesses < taskQueue->size) {
        int i = taskQueue->front;
        int highestPriority = INT_MAX;
        int selectedProcessIndex = -1;
        while (i <= taskQueue->rear) {
            struct Process* process = &taskQueue->processes[i];
            if (process->remainingTime > 0 && process->priority < highestPriority && process->arrivalTime <= currentTime) {
                highestPriority = process->priority;
                selectedProcessIndex = i;
            }
            i = (i + 1) % MAX_PROCESSES;
        }
        if (selectedProcessIndex != -1) {
            struct Process* process = &taskQueue->processes[selectedProcessIndex];
            int executionTime = process->remainingTime;
            process->remainingTime -= executionTime;
            currentTime += executionTime;

            // Store the Gantt chart entry
            strcpy(ganttChart[ganttIndex].processName, process->name);
            ganttChart[ganttIndex].startTime = currentTime - executionTime;
            ganttChart[ganttIndex].endTime = currentTime;
            ganttIndex++;

            // Print the execution order
            if (process->remainingTime == 0) {
                printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", ganttChart[ganttIndex - 1].startTime, currentTime, process->name);
            } else {
                printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", ganttChart[ganttIndex - 1].startTime, currentTime, process->name, process->remainingTime);
            }

            // Process completed
            if (process->remainingTime == 0) {
                process->completionTime = currentTime;
                process->turnaroundTime = process->completionTime - process->arrivalTime;
                process->waitingTime = process->turnaroundTime - process->burstTime;
                completedProcesses++;
            }
        } else {
            currentTime++;
        }
    }

    // Set the start time for each process based on the first appearance in the Gantt chart
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];
        int found = 0;
        for (int j = 0; j < ganttIndex; j++) {
            if (strcmp(process->name, ganttChart[j].processName) == 0) {
                process->startTime = ganttChart[j].startTime;
                found = 1;
                break;
            }
        }
        if (!found) {
            // If the process doesn't have a corresponding entry in the Gantt chart, set its start time to -1
            process->startTime = -1;
        }
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------------------------------------------------------------------\n");
    printf("| ");
    for (int i = 0; i < ganttIndex; i++) {
        printf("%s ", ganttChart[i].processName);
        if (i < ganttIndex - 1) {
            printf("| ");
        }
    }
    printf("|\n");
    printf("---------------------------------------------------------------------\n");
    printf("0");
    for (int i = 0; i < ganttIndex; i++) {
        printf("------%d", ganttChart[i].endTime);
    }
    printf("\n");

    // Print the process table and metrics table
    printProcessTable(taskQueue);
    printMetricsTable(taskQueue);
}

//clears the input buffer
void clearInputBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        // Discard characters until a newline or EOF is encountered
    }
}
//initializes the original task queue
void initializeOriginalTaskQueue(struct TaskQueue* taskQueue) {
    originalTaskQueue.front = taskQueue->front;
    originalTaskQueue.rear = taskQueue->rear;
    originalTaskQueue.size = taskQueue->size;
    for (int i = taskQueue->front; i <= taskQueue->rear; i++) {
        originalTaskQueue.processes[i] = taskQueue->processes[i];
    }
}


int main() {
    struct TaskQueue taskQueue;
    taskQueue.front = 0;
    taskQueue.rear = -1;
    taskQueue.size = 0;
    int option, timeQuantum;
    struct Process process;

    do {
        printf("\nDynamic Scheduling Menu\n");
        printf("1. Add Process\n");
        printf("2. Remove Process\n");
        printf("3. Run SJF Scheduling\n");
        printf("4. Run Round Robin Scheduling\n");
        printf("5. Run Priority Scheduling (lower number represents higher priority)\n");
        printf("6. Run FCFS Scheduling\n");
        printf("7. Exit\n");
        printf("Enter your option: ");
        scanf("%d", &option);
        char processName[20];
        int schedulingOption;

        switch (option) {
            case 1:
                // Add a process to the task queue
                printf("Enter process name: ");
                scanf("%s", processName);
                strcpy(process.name, processName);
                // Check for duplicate process names before completing the input
                for (int i = taskQueue.front; i <= taskQueue.rear; i++) {
                    if (strcmp(taskQueue.processes[i].name, process.name) == 0) {
                        printf("Error: Process with name '%s' already exists. Cannot add duplicate processes.\n", process.name);
                        process.name[0] = '\0';  // Clear the process name
                        break;
                    }
                }
                if (process.name[0] > '\0') {
                    int validInput = 0; // Flag to track valid input
                    while (!validInput) {
                        printf("Enter arrival time: ");
                        if (scanf("%d", &process.arrivalTime) != 1) {
                            printf("Invalid input for arrival time. Please enter an integer.\n");
                            clearInputBuffer();
                            continue;
                        }
                        printf("Enter burst time: ");
                        if (scanf("%d", &process.burstTime) != 1) {
                            printf("Invalid input for burst time. Please enter an integer.\n");
                            clearInputBuffer();
                            continue;
                        }
                        printf("Enter priority: ");
                        if (scanf("%d", &process.priority) != 1) {
                            printf("Invalid input for priority. Please enter an integer.\n");
                            clearInputBuffer();
                            continue;
                        }
                        validInput = 1;
                    }
                    process.remainingTime = process.burstTime;
                    process.completionTime = 0;
                    process.turnaroundTime = 0;
                    process.waitingTime = 0;
                    enqueue(&taskQueue, process);
                    numOfAddedProcesses += 1;
                }
                break;
            case 2:
                if (numOfAddedProcesses > 0){
                    // Remove a process from the task queue
                    printf("\nEnter the name of the process to remove: ");
                    scanf("%s", process.name);
                    removeProcess(&taskQueue, process.name);
                    numOfAddedProcesses -= 1;
                }
                else {
                    printf("No processes added. Please add processes first.\n");
                    clearInputBuffer();
                    continue;
                }
                break;
            case 3:
                printf("Select scheduling option:\n");
                printf("1. Preemptive\n");
                printf("2. Non-preemptive\n");
                printf("Enter your option: ");
                scanf("%d", &schedulingOption);
                if (numOfAddedProcesses > 0) {
                    initializeOriginalTaskQueue(&taskQueue);  // Initialize the original task queue
                    if (schedulingOption == 1) {
                        sjfPreemptiveScheduling(&taskQueue);
                        printf("Preemptive SJF Scheduling completed.\n");
                    } else if (schedulingOption == 2) {
                        sjfNonPreemptiveScheduling(&taskQueue);
                        printf("Non-preemptive SJF Scheduling completed.\n");
                    } else {
                        printf("Invalid option. Please enter a valid option.\n");
                    }
                    // Reset the task queue to the original state
                    taskQueue.front = originalTaskQueue.front;
                    taskQueue.rear = originalTaskQueue.rear;
                    taskQueue.size = originalTaskQueue.size;
                    for (int i = taskQueue.front; i <= taskQueue.rear; i++) {
                        taskQueue.processes[i] = originalTaskQueue.processes[i];
                    }
                } else {
                    printf("No processes added. Please add processes first.\n");
                    clearInputBuffer();
                    continue;
                }
                break;

            case 4:
                if (numOfAddedProcesses > 0) {
                    initializeOriginalTaskQueue(&taskQueue);  // Initialize the original task queue
                    printf("Enter the time quantum: ");
                    scanf("%d", &timeQuantum);
                    roundRobinScheduling(&taskQueue, timeQuantum);
                    printf("Round Robin Scheduling completed.\n");
                    // Reset the task queue to the original state
                    taskQueue.front = originalTaskQueue.front;
                    taskQueue.rear = originalTaskQueue.rear;
                    taskQueue.size = originalTaskQueue.size;
                    for (int i = taskQueue.front; i <= taskQueue.rear; i++) {
                        taskQueue.processes[i] = originalTaskQueue.processes[i];
                    }
                } else {
                    printf("No processes added. Please add processes first.\n");
                    clearInputBuffer();
                    continue;
                }
                break;

            case 5:

                printf("Select scheduling option:\n");
                printf("1. Preemptive\n");
                printf("2. Non-preemptive\n");
                printf("Enter your option: ");
                scanf("%d", &schedulingOption);

                if (numOfAddedProcesses > 0) {
                    initializeOriginalTaskQueue(&taskQueue);  // Initialize the original task queue
                    if (schedulingOption == 1) {
                        prioritySchedulingWithPreemption(&taskQueue);
                    } else if (schedulingOption == 2){
                        prioritySchedulingWithoutPreemption( &taskQueue);
                    }
                    printf("Priority Scheduling completed.\n");
                    // Reset the task queue to the original state
                    taskQueue.front = originalTaskQueue.front;
                    taskQueue.rear = originalTaskQueue.rear;
                    taskQueue.size = originalTaskQueue.size;
                    for (int i = taskQueue.front; i <= taskQueue.rear; i++) {
                        taskQueue.processes[i] = originalTaskQueue.processes[i];
                    }
                } else {
                    printf("No processes added. Please add processes first.\n");
                    clearInputBuffer();
                    continue;
                }
                break;



            case 6:
                if (numOfAddedProcesses > 0) {
                    initializeOriginalTaskQueue(&taskQueue);  // Initialize the original task queue
                    fcfsScheduling(&taskQueue);
                    printf("FCFS Scheduling completed.\n");
                    // Reset the task queue to the original state
                    taskQueue.front = originalTaskQueue.front;
                    taskQueue.rear = originalTaskQueue.rear;
                    taskQueue.size = originalTaskQueue.size;
                    for (int i = taskQueue.front; i <= taskQueue.rear; i++) {
                        taskQueue.processes[i] = originalTaskQueue.processes[i];
                    }
                } else {
                    printf("No processes added. Please add processes first.\n");
                    clearInputBuffer();
                    continue;
                }
                break;

            case 7:
                printf("Exiting the program.\n");
                break;

            default:
                printf("Invalid option. Please try again.\n");
        }
    } while (option != 7);

    return 0;
}
