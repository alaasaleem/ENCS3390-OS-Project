#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NAME_LENGTH 10
#define MAX_PROCESSES 100

// Structure to represent a process
struct Process {
    char name[MAX_NAME_LENGTH];
    int arrivalTime;
    int burstTime;
    int remainingTime;
    int completionTime;
    int turnaroundTime;
    int waitingTime;
    int priority;
};

// Structure to represent a task queue
struct TaskQueue {
    struct Process processes[MAX_PROCESSES];
    int front;
    int rear;
    int size;
};

// Function prototypes
void enqueue(struct TaskQueue* queue, struct Process process);
struct Process dequeue(struct TaskQueue* queue);
int isQueueEmpty(struct TaskQueue* queue);
void sjfScheduling(struct TaskQueue* taskQueue);
void roundRobinScheduling(struct TaskQueue* taskQueue, int timeQuantum);
void priorityScheduling(struct TaskQueue* taskQueue);
void printProcessTable(struct TaskQueue* taskQueue);
void printMetricsTable(struct TaskQueue* taskQueue);
float calculateAverageTurnaroundTime(struct TaskQueue* taskQueue);
float calculateAverageWaitingTime(struct TaskQueue* taskQueue);
void removeProcess(struct TaskQueue* queue, char* processName);
void resetTaskQueue(struct TaskQueue* taskQueue);

int min(int a, int b);

void removeProcess(struct TaskQueue* queue, char* processName) {
    int found = 0;

    for (int i = queue->front; i <= queue->rear; i++) {
        if (strcmp(queue->processes[i].name, processName) == 0) {
            found = 1;
            // Shift the remaining processes to the left
            for (int j = i; j < queue->rear; j++) {
                queue->processes[j] = queue->processes[j + 1];
            }
            queue->rear--;
            queue->size--;
            break;
        }
    }

    if (found) {
        printf("Process '%s' removed successfully.\n", processName);
    } else {
        printf("Process '%s' not found in the task queue.\n", processName);
    }
}


// Enqueues a process into the task queue
void enqueue(struct TaskQueue* queue, struct Process process) {
    if (queue->rear == MAX_PROCESSES - 1) {
        printf("Queue is full. Cannot enqueue more tasks.\n");
        return;
    }

    // Increase the rear index and add the process to the queue
    queue->rear++;
    queue->processes[queue->rear] = process;
    queue->size++;
}

// Dequeues a process from the task queue
struct Process dequeue(struct TaskQueue* queue) {
    if (isQueueEmpty(queue)) {
        // Return an empty process if the queue is empty
        struct Process emptyProcess;
        strcpy(emptyProcess.name, "");
        emptyProcess.arrivalTime = 0;
        emptyProcess.burstTime = 0;
        emptyProcess.remainingTime = 0;
        emptyProcess.completionTime = 0;
        emptyProcess.turnaroundTime = 0;
        emptyProcess.waitingTime = 0;
        emptyProcess.priority = 0;
        return emptyProcess;
    }

    // Retrieve the process at the front of the queue
    struct Process dequeuedProcess = queue->processes[queue->front];

    // Increase the front index and decrease the queue size
    queue->front++;
    queue->size--;

    if (queue->size == 0) {
        // Reset the queue indices if the queue becomes empty
        queue->front = 0;
        queue->rear = -1;
    }

    return dequeuedProcess;
}

// Checks if the task queue is empty
int isQueueEmpty(struct TaskQueue* queue) {
    return (queue->size == 0);
}

// Performs SJF scheduling on the task queue
void sjfScheduling(struct TaskQueue* taskQueue) {
    // Sort the tasks based on burst time using bubble sort
    for (int i = 0; i < taskQueue->size - 1; i++) {
        for (int j = 0; j < taskQueue->size - i - 1; j++) {
            if (taskQueue->processes[j].burstTime > taskQueue->processes[j + 1].burstTime) {
                // Swap the processes if the current process has higher burst time than the next process
                struct Process temp = taskQueue->processes[j];
                taskQueue->processes[j] = taskQueue->processes[j + 1];
                taskQueue->processes[j + 1] = temp;
            }
        }
    }

    int currentTime = 0;

    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];

        // Calculate waiting time
        process->waitingTime = currentTime - process->arrivalTime;
        if (process->waitingTime < 0)
            process->waitingTime = 0;

        // Calculate completion time and turnaround time
        process->completionTime = currentTime + process->burstTime;
        process->turnaroundTime = process->completionTime - process->arrivalTime;

        currentTime = process->completionTime;
    }
    
        // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("--------");
    }
    printf("\n|");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("   %s    |", taskQueue->processes[i].name);
    }
    printf("\n---------");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("--------");
    }
    printf("\n0");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("--------%d", taskQueue->processes[i].completionTime);
    }
    printf("\n");
}



void simulateCompletion(struct TaskQueue* taskQueue) {
    int currentTime = 0;
    int orderPrinted = 0; // Variable to track if the order has been printed



    // Print processes with arrival time
    printf("\nProcess %s (Arrival Time: %d)\n", taskQueue->processes[taskQueue->front].name, taskQueue->processes[taskQueue->front].arrivalTime);
    for (int i = taskQueue->front + 1; i <= taskQueue->rear; i++) {
        printf("Process %s (Arrival Time: %d)\n", taskQueue->processes[i].name, taskQueue->processes[i].arrivalTime);
        printf("\n");
    }
    printf("\nThe order in which processes or threads are selected for execution:\n");
    while (!isQueueEmpty(taskQueue)) {
        struct Process* currentProcess = &taskQueue->processes[taskQueue->front];

        if (currentProcess->arrivalTime <= currentTime) {
            // Process can be executed
            int startExecutionTime = currentTime;
            int remainingBurstTime = currentProcess->remainingTime;
            int completionTime = currentTime + remainingBurstTime;

            if (!orderPrinted) { // Check if the order has been printed
                printf("\nFrom \"%d\" to \"%d\": \"%s\"\n", startExecutionTime, completionTime, currentProcess->name);
                orderPrinted = 1; // Set the flag to indicate that the order has been printed
            }

            while (remainingBurstTime) {
                int executionTime = min(remainingBurstTime, 1); // Simulate execution for 1 unit of time

                currentTime += executionTime;
                currentProcess->remainingTime -= executionTime;
                remainingBurstTime -= executionTime;
            }

            if (currentProcess->remainingTime == 0) {
                // Process completed
                currentProcess->completionTime = currentTime;
                currentProcess->turnaroundTime = currentProcess->completionTime - currentProcess->arrivalTime;
                currentProcess->waitingTime = currentProcess->turnaroundTime - currentProcess->burstTime;

                printf("\nProcess %s completed at time %d.\n", currentProcess->name, currentProcess->completionTime);
                dequeue(taskQueue);

                orderPrinted = 0; // Reset the flag to allow printing the order for the next process
            }
        } else {
            // No process available for execution at the current time
            currentTime++;
            orderPrinted = 0; // Reset the flag as the order cannot be printed for this time slot
        }
    }
}

// Finds the minimum of two numbers
int min(int a, int b) {
    return (a < b) ? a : b;
}

// Performs round-robin scheduling on the task queue with a given time quantum
void roundRobinScheduling(struct TaskQueue* taskQueue, int timeQuantum) {
    int currentTime = 0;
    int completedProcesses = 0;

    // Create a Gantt chart array to store process names and corresponding execution times
    struct GanttEntry {
        char processName[10];
        int executionTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES * 100];  // Assuming maximum 100 time slots per process

    int ganttIndex = 0;  // Index to keep track of the Gantt chart entries

    while (completedProcesses < taskQueue->size) {
        int i = taskQueue->front;

        while (i <= taskQueue->rear) {
            struct Process* process = &taskQueue->processes[i];

            if (process->remainingTime > 0) {
                int executionTime = (process->remainingTime > timeQuantum) ? timeQuantum : process->remainingTime;

                process->remainingTime -= executionTime;
                currentTime += executionTime;

                // Store the Gantt chart entry
                strcpy(ganttChart[ganttIndex].processName, process->name);
                ganttChart[ganttIndex].executionTime = executionTime;
                ganttIndex++;

                if (process->remainingTime == 0) {
                    // Process completed
                    process->completionTime = currentTime;
                    process->turnaroundTime = process->completionTime - process->arrivalTime;
                    process->waitingTime = process->turnaroundTime - process->burstTime;
                    completedProcesses++;
                }
            }

            i = (i + 1) % MAX_PROCESSES;  // Circularly traverse the queue
        }
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("-------------\n");
    for (int i = 0; i < ganttIndex; i++) {
        printf("| %s ", ganttChart[i].processName);
    }
    printf("|\n");
    printf("-------------\n");
    printf("0");
    int cumulativeTime = 0;
    for (int i = 0; i < ganttIndex; i++) {
        cumulativeTime += ganttChart[i].executionTime;
        printf("------%d", cumulativeTime);
    }
    printf("\n");
}



void priorityScheduling(struct TaskQueue* taskQueue) {
    // Sort the tasks based on priority using bubble sort
    for (int i = 0; i < taskQueue->size - 1; i++) {
        for (int j = 0; j < taskQueue->size - i - 1; j++) {
            if (taskQueue->processes[j].priority > taskQueue->processes[j + 1].priority) {
                // Swap the processes if the current process has higher priority than the next process
                struct Process temp = taskQueue->processes[j];
                taskQueue->processes[j] = taskQueue->processes[j + 1];
                taskQueue->processes[j + 1] = temp;
            } else if (taskQueue->processes[j].priority == taskQueue->processes[j + 1].priority) {
                // If two processes have equal priority, the one with a lower arrival time should have higher priority
                if (taskQueue->processes[j].arrivalTime > taskQueue->processes[j + 1].arrivalTime) {
                    struct Process temp = taskQueue->processes[j];
                    taskQueue->processes[j] = taskQueue->processes[j + 1];
                    taskQueue->processes[j + 1] = temp;
                }
            }
        }
    }

    int currentTime = 0;

    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];

        // Calculate waiting time
        process->waitingTime = currentTime - process->arrivalTime;
        if (process->waitingTime < 0)
            process->waitingTime = 0;

        // Calculate completion time and turnaround time
        process->completionTime = currentTime + process->burstTime;
        process->turnaroundTime = process->completionTime - process->arrivalTime;

        currentTime = process->completionTime;
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("-----------------------------------------\n");
    printf("| ");
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];
        printf("%s\t| ", process->name);
    }
    printf("\n");
    printf("-----------------------------------------\n");

    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];
        printf("%d", process->completionTime - process->burstTime);

        for (int j = 0; j < strlen(process->name) + 1; j++) {
            printf(" ");
        }

        if (i == taskQueue->size - 1) {
            printf("%d", process->completionTime);
        }

        printf("\t");
    }
    printf("\n");
}




// Prints the process table
void printProcessTable(struct TaskQueue* taskQueue) {
    printf("\nProcess Table:\n");
    printf("+-------+-----------------+------------------+--------------+\n");
    printf("| Name  | Arrival Time    | Burst Time       | Priority     |\n");
    printf("|       |                 |                  |              |\n");
    printf("+-------+-----------------+------------------+--------------+\n");

    for (int i = taskQueue->front; i <= taskQueue->rear; i++) {
        printf("| %-5s | %-15d | %-16d | %-12d |\n",
               taskQueue->processes[i].name, taskQueue->processes[i].arrivalTime,
               taskQueue->processes[i].burstTime, taskQueue->processes[i].priority);
    }

    printf("+-------+-----------------+------------------+--------------+\n");
}

// Prints the metrics table
void printMetricsTable(struct TaskQueue* taskQueue) {
    printf("\nMetrics Table:\n");
    printf("+-------+-----------------+------------------+----------------+----------------+-----------------+\n");
    printf("| Name  | Completion Time | Turnaround Time  | Waiting Time   | Response Time  | Throughput      |\n");
    printf("|       |                 |                  |                |                | (processes/sec) |\n");
    printf("+-------+-----------------+------------------+----------------+----------------+-----------------+\n");

    for (int i = taskQueue->front; i <= taskQueue->rear; i++) {
        printf("| %-5s | %-15d | %-16d | %-14d | %-14d | %-15.2f |\n",
               taskQueue->processes[i].name, taskQueue->processes[i].completionTime,
               taskQueue->processes[i].turnaroundTime, taskQueue->processes[i].waitingTime,
               taskQueue->processes[i].waitingTime, 1.0 / taskQueue->processes[i].turnaroundTime);
    }

    printf("+-------+-----------------+------------------+----------------+----------------+-----------------+\n");

    printf("\nAverage Turnaround Time: %.2f\n", calculateAverageTurnaroundTime(taskQueue));
    printf("Average Waiting Time: %.2f\n", calculateAverageWaitingTime(taskQueue));
}

// Calculates the average turnaround time of the processes in the task queue
float calculateAverageTurnaroundTime(struct TaskQueue* taskQueue) {
    int totalTurnaroundTime = 0;

    for (int i = taskQueue->front; i <= taskQueue->rear; i++) {
        totalTurnaroundTime += taskQueue->processes[i].turnaroundTime;
    }

    return (float)totalTurnaroundTime / taskQueue->size;
}

// Calculates the average waiting time of the processes in the task queue
float calculateAverageWaitingTime(struct TaskQueue* taskQueue) {
    int totalWaitingTime = 0;

    for (int i = taskQueue->front; i <= taskQueue->rear; i++) {
        totalWaitingTime += taskQueue->processes[i].waitingTime;
    }

    return (float)totalWaitingTime / taskQueue->size;
}



void resetTaskQueue(struct TaskQueue* taskQueue) {
    for (int i = taskQueue->front; i <= taskQueue->rear; i++) {
        taskQueue->processes[i].remainingTime = taskQueue->processes[i].burstTime;
        taskQueue->processes[i].completionTime = 0;
        taskQueue->processes[i].turnaroundTime = 0;
        taskQueue->processes[i].waitingTime = 0;
    }
}


int main() {
    struct TaskQueue taskQueue;
    taskQueue.front = 0;
    taskQueue.rear = -1;
    taskQueue.size = 0;

    int option, timeQuantum;
    struct Process process;

    do {
        printf("\nDynamic Scheduling Menu\n");
        printf("1. Add Process\n");
        printf("2. Remove Process\n");
        printf("3. Run SJF Scheduling\n");
        printf("4. Run Round Robin Scheduling\n");
        printf("5. Run Priority Scheduling\n");
        printf("6. Print Process Table\n");
        printf("7. Print Metrics Table\n");
        printf("8. Genarate tasks and simulate Completion and Arrival Time\n");
        printf("9. Genarate Reports\n");        
        printf("10. Exit\n");
        printf("Enter your option: ");
        scanf("%d", &option);
        
        int numTasks;
            
        switch (option) {
            case 1:
                // Add a process to the task queue
                printf("\nEnter process details:\n");
                printf("Name: ");
                scanf("%s", process.name);
                printf("Arrival Time: ");
                scanf("%d", &process.arrivalTime);
                printf("Burst Time: ");
                scanf("%d", &process.burstTime);
                printf("Priority: ");
                scanf("%d", &process.priority);
                process.remainingTime = process.burstTime;

                enqueue(&taskQueue, process);
                printf("Process enqueued successfully.\n");
                break;
            case 2:
                // Remove a process from the task queue
                printf("\nEnter the name of the process to remove: ");
                scanf("%s", process.name);
                removeProcess(&taskQueue, process.name);
                break;
            case 3:
                sjfScheduling(&taskQueue);
                printf("SJF Scheduling completed.\n");
                break;
            case 4:
                printf("Enter the time quantum: ");
                scanf("%d", &timeQuantum);
                roundRobinScheduling(&taskQueue, timeQuantum);
                printf("Round Robin Scheduling completed.\n");
                break;
            case 5:
                priorityScheduling(&taskQueue);
                printf("Priority Scheduling completed.\n");
                break;
            case 6:
                printProcessTable(&taskQueue);
                break;
            case 7:
                printMetricsTable(&taskQueue);
                break;
            case 8:
            // Generate a sequence of tasks
            printf("Enter the number of tasks: ");
            scanf("%d", &numTasks);

            for (int i = 0; i < numTasks; i++) {
                printf("\nEnter details for Task %d:\n", i + 1);
                printf("Name: ");
                scanf("%s", process.name);
                printf("Arrival Time: ");
                scanf("%d", &process.arrivalTime);
                printf("Burst Time: ");
                scanf("%d", &process.burstTime);
                printf("Priority: ");
                scanf("%d", &process.priority);
                process.remainingTime = process.burstTime;

                enqueue(&taskQueue, process);
                printf("Task enqueued successfully.\n");
            }
                        // Simulate completion of tasks
            simulateCompletion(&taskQueue);
            printf("Task completion simulation completed.\n");

            break;

            
            case 9:
                printf("\nEnter the time quantum for the Round Robin: ");
                scanf("%d", &timeQuantum);
                printf("*************************************** SJF Scheduling Performance Metrics ***********************************************\n");
                sjfScheduling(&taskQueue);
                printMetricsTable(&taskQueue);
                resetTaskQueue(&taskQueue);

                printf("\n*************************************** Round Robin Scheduling Performance Metrics ***********************************************\n");
                roundRobinScheduling(&taskQueue, timeQuantum); 
                printMetricsTable(&taskQueue);
                resetTaskQueue(&taskQueue);    

                printf("\n*************************************** Priority Scheduling Performance Metrics ***********************************************\n");
                priorityScheduling(&taskQueue);
                printMetricsTable(&taskQueue);
                resetTaskQueue(&taskQueue);                  
                break;
            
            case 10:
                printf("Exiting the program.\n");
                break;           
            

            default:
                printf("Invalid option. Please try again.\n");
        }
    } while (option != 10);

    return 0;

}
