#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#define MAX_NAME_LENGTH 10
#define MAX_PROCESSES 100

// Structure to represent a process
struct Process {
    char name[MAX_NAME_LENGTH];
    int arrivalTime;
    int burstTime;
    int remainingTime;
    int completionTime;
    int turnaroundTime;
    int waitingTime;
    int priority;
};

// Structure to represent a task queue
struct TaskQueue {
    struct Process processes[MAX_PROCESSES];
    int front;
    int rear;
    int size;
};

// Function prototypes
void enqueue(struct TaskQueue* queue, struct Process process);
struct Process dequeue(struct TaskQueue* queue);
int isQueueEmpty(struct TaskQueue* queue);
void sjfScheduling(struct TaskQueue* taskQueue);
void roundRobinScheduling(struct TaskQueue* taskQueue, int timeQuantum);
void prioritySchedulingWithPreemption(struct TaskQueue* taskQueue);
void printProcessTable(struct TaskQueue* taskQueue);
void printMetricsTable(struct TaskQueue* taskQueue);
void removeProcess(struct TaskQueue* queue, char* processName);
int min(int a, int b);

void removeProcess(struct TaskQueue* queue, char* processName) {
    int found = 0;

    for (int i = queue->front; i <= queue->rear; i++) {
        if (strcmp(queue->processes[i].name, processName) == 0) {
            found = 1;
            // Shift the remaining processes to the left
            for (int j = i; j < queue->rear; j++) {
                queue->processes[j] = queue->processes[j + 1];
            }
            queue->rear--;
            queue->size--;
            break;
        }
    }

    if (found) {
        printf("Process '%s' removed successfully.\n", processName);
    } else {
        printf("Process '%s' not found in the task queue.\n", processName);
    }
}
// Enqueues a process into the task queue
void enqueue(struct TaskQueue* queue, struct Process process) {
    if (queue->rear == MAX_PROCESSES - 1) {
        printf("Queue is full. Cannot enqueue more tasks.\n");
        return;
    }

    // Increase the rear index and add the process to the queue
    queue->rear++;
    queue->processes[queue->rear] = process;
    queue->size++;
}
// Dequeues a process from the task queue
struct Process dequeue(struct TaskQueue* queue) {
    if (isQueueEmpty(queue)) {
        // Return an empty process if the queue is empty
        struct Process emptyProcess;
        strcpy(emptyProcess.name, "");
        emptyProcess.arrivalTime = 0;
        emptyProcess.burstTime = 0;
        emptyProcess.remainingTime = 0;
        emptyProcess.completionTime = 0;
        emptyProcess.turnaroundTime = 0;
        emptyProcess.waitingTime = 0;
        emptyProcess.priority = 0;
        return emptyProcess;
    }

    // Retrieve the process at the front of the queue
    struct Process dequeuedProcess = queue->processes[queue->front];

    // Increase the front index and decrease the queue size
    queue->front++;
    queue->size--;

    if (queue->size == 0) {
        // Reset the queue indices if the queue becomes empty
        queue->front = 0;
        queue->rear = -1;
    }

    return dequeuedProcess;
}
// Checks if the task queue is empty
int isQueueEmpty(struct TaskQueue* queue) {
    return (queue->size == 0);
}
// Finds the minimum of two numbers
int min(int a, int b) {
    return (a < b) ? a : b;
}

// Performs round-robin scheduling on the task queue with a given time quantum
void roundRobinScheduling(struct TaskQueue* taskQueue, int timeQuantum) {
    int currentTime = 0;
    int completedProcesses = 0;

    // Create a Gantt chart array to store process names and corresponding execution times
    struct GanttEntry {
        char processName[10];
        int executionTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES * 100];  // Assuming maximum 100 time slots per process

    int ganttIndex = 0;  // Index to keep track of the Gantt chart entries

    while (completedProcesses < taskQueue->size) {
        int i = taskQueue->front;

        while (i <= taskQueue->rear) {
            struct Process* process = &taskQueue->processes[i];

            if (process->remainingTime > 0) {
                int executionTime = (process->remainingTime > timeQuantum) ? timeQuantum : process->remainingTime;

                process->remainingTime -= executionTime;
                currentTime += executionTime;

                // Store the Gantt chart entry
                strcpy(ganttChart[ganttIndex].processName, process->name);
                ganttChart[ganttIndex].executionTime = executionTime;
                ganttIndex++;
                
                
                // Print the execution order
                if (process->arrivalTime <= currentTime - executionTime) {
                    if (process->remainingTime == 0) {
                        printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", currentTime - executionTime, currentTime, process->name);
                    } else {
                        printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", currentTime - executionTime, currentTime, process->name, process->remainingTime);
                    }
                }

                if (process->remainingTime == 0) {
                    // Process completed
                    process->completionTime = currentTime;
                    process->turnaroundTime = process->completionTime - process->arrivalTime;
                    process->waitingTime = process->turnaroundTime - process->burstTime;
                    completedProcesses++;
                }
            }

            i = (i + 1) % MAX_PROCESSES;  // Circularly traverse the queue
        }
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------------------------------------------------------------------\n");
    for (int i = 0; i < ganttIndex; i++) {
        printf("| %s ", ganttChart[i].processName);
    }
    printf("|\n");
    printf("----------------------------------------------------------------------\n");
    printf("0");
    int cumulativeTime = 0;
    for (int i = 0; i < ganttIndex; i++) {
        cumulativeTime += ganttChart[i].executionTime;
        printf("------%d", cumulativeTime);
    }
    printf("\n");
}


// Performs FCFS scheduling on the task queue
void fcfsScheduling(struct TaskQueue* taskQueue) {
    int currentTime = 0;
    int completedProcesses = 0;

    // Create a Gantt chart array to store process names and corresponding execution times
    struct GanttEntry {
        char processName[10];
        int executionTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES * 100];  // Assuming maximum 100 time slots per process

    int ganttIndex = 0;  // Index to keep track of the Gantt chart entries

    // Print processes with arrival time
    printf("\nProcess %s (Arrival Time: %d)\n", taskQueue->processes[taskQueue->front].name, taskQueue->processes[taskQueue->front].arrivalTime);
    for (int i = taskQueue->front + 1; i <= taskQueue->rear; i++) {
        printf("Process %s (Arrival Time: %d)\n", taskQueue->processes[i].name, taskQueue->processes[i].arrivalTime);
        printf("\n");
    }
    printf("\nThe order in which processes or threads are selected for execution:\n");

    while (completedProcesses < taskQueue->size) {
        int i = taskQueue->front;

        while (i <= taskQueue->rear) {
            struct Process* process = &taskQueue->processes[i];

            if (process->remainingTime > 0 && process->arrivalTime <= currentTime) {
                int executionTime = process->remainingTime;

                process->remainingTime -= executionTime;
                currentTime += executionTime;

                // Store the Gantt chart entry
                strcpy(ganttChart[ganttIndex].processName, process->name);
                ganttChart[ganttIndex].executionTime = executionTime;
                ganttIndex++;

                // Print the execution order
                printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", currentTime - executionTime, currentTime, process->name);

                if (process->remainingTime == 0) {
                    // Process completed
                    process->completionTime = currentTime;
                    process->turnaroundTime = process->completionTime - process->arrivalTime;
                    process->waitingTime = process->turnaroundTime - process->burstTime;
                    completedProcesses++;
                }
            }

            i++;
        }

        currentTime++;
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("-------------\n");
    for (int i = 0; i < ganttIndex; i++) {
        printf("| %s ", ganttChart[i].processName);
    }
    printf("|\n");
    printf("-------------\n");
    printf("0");
    int cumulativeTime = 0;
    for (int i = 0; i < ganttIndex; i++) {
        cumulativeTime += ganttChart[i].executionTime;
        printf("------%d", cumulativeTime);
    }
    printf("\n");
}

// Performs SJF scheduling on the task queue
void sjfScheduling(struct TaskQueue* taskQueue) {
    // Sort the tasks based on burst time using bubble sort
    for (int i = 0; i < taskQueue->size - 1; i++) {
        for (int j = 0; j < taskQueue->size - i - 1; j++) {
            if (taskQueue->processes[j].burstTime > taskQueue->processes[j + 1].burstTime) {
                // Swap the processes if the current process has higher burst time than the next process
                struct Process temp = taskQueue->processes[j];
                taskQueue->processes[j] = taskQueue->processes[j + 1];
                taskQueue->processes[j + 1] = temp;
            }
        }
    }

    int currentTime = 0;

    printf("The order in which processes or threads are selected for execution:\n");
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];

        // Calculate waiting time
        process->waitingTime = currentTime - process->arrivalTime;
        if (process->waitingTime < 0)
            process->waitingTime = 0;

        // Calculate completion time and turnaround time
        process->completionTime = currentTime + process->burstTime;
        process->turnaroundTime = process->completionTime - process->arrivalTime;

        currentTime = process->completionTime;

        // Print the execution order
        if (process->burstTime == 0) {
            printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", currentTime - process->burstTime, currentTime, process->name);
        } else {
            printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", currentTime - process->burstTime, currentTime, process->name, process->burstTime);
        }
    }

    // Print the process details
    printf("\nProcess Details:\n");
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process process = taskQueue->processes[i];
        printf("Process %s (Arrival Time: %d)\n", process.name, process.arrivalTime);
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("--------");
    }
    printf("\n|");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("   %s    |", taskQueue->processes[i].name);
    }
    printf("\n---------");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("--------");
    }
    printf("\n0");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("--------%d", taskQueue->processes[i].completionTime);
    }
    printf("\n");
}

// Helper function to reset the task queue
void resetTaskQueue(struct TaskQueue* taskQueue) {
    taskQueue->front = 0;
    taskQueue->rear = -1;
    taskQueue->size = 0;
}
// Prints the process table
void printProcessTable(struct TaskQueue* taskQueue) {
    printf("\nProcess Table:\n");
    printf("+-------+-----------------+------------------+--------------+\n");
    printf("| Name  | Arrival Time    | Burst Time       | Priority     |\n");
    printf("|       |                 |                  |              |\n");
    printf("+-------+-----------------+------------------+--------------+\n");

    for (int i = taskQueue->front; i <= taskQueue->rear; i++) {
        printf("| %-5s | %-15d | %-16d | %-12d |\n",
               taskQueue->processes[i].name, taskQueue->processes[i].arrivalTime,
               taskQueue->processes[i].burstTime, taskQueue->processes[i].priority);
    }

    printf("+-------+-----------------+------------------+--------------+\n");
}

// Helper function to calculate and print the metrics table
void printMetricsTable(struct TaskQueue* taskQueue) {
    float totalWaitingTime = 0;
    float totalTurnaroundTime = 0;

    printf("\nMetrics Table:\n");
    printf("-----------------------------------------------------------------------------------------------------\n");
    printf("| Process | Arrival Time | Burst Time | Priority | Completion Time | Turnaround Time | Waiting Time |\n");
    printf("-----------------------------------------------------------------------------------------------------\n");

    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];

        totalWaitingTime += process->waitingTime;
        totalTurnaroundTime += process->turnaroundTime;
 
        printf("| %s      |      %d       |     %d      |     %d    |         %d       |        %d         |        %d    |\n",
               process->name, process->arrivalTime, process->burstTime, process->priority,
               process->completionTime, process->turnaroundTime, process->waitingTime);
    }

    printf("-----------------------------------------------------------------------------------------------------\n");
    printf("  AWT = %.2f\n", totalWaitingTime / taskQueue->size);
    printf("  TAT = %.2f\n", totalTurnaroundTime / taskQueue->size);
    printf("-----------------------------------------------------------------------------------------------------\n");
}


// Performs priority scheduling on the task queue with preemption
void prioritySchedulingWithPreemption(struct TaskQueue* taskQueue) {
    int currentTime = 0;
    int completedProcesses = 0;
    int timeQuantum = 1;

    struct GanttEntry {
        char processName[10];
        int executionTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES];

    int ganttIndex = 0;

    printf("\nProcess %s (Arrival Time: %d)\n", taskQueue->processes[taskQueue->front].name, taskQueue->processes[taskQueue->front].arrivalTime);
    for (int i = taskQueue->front + 1; i <= taskQueue->rear; i++) {
        printf("Process %s (Arrival Time: %d)\n", taskQueue->processes[i].name, taskQueue->processes[i].arrivalTime);
        printf("\n");
    }
    printf("\nThe order in which processes or threads are selected for execution:\n");

    while (completedProcesses < taskQueue->size) {
        int i = taskQueue->front;
        int highestPriority = INT_MAX;
        int selectedProcessIndex = -1;

        while (i <= taskQueue->rear) {
            struct Process* process = &taskQueue->processes[i];

            if (process->remainingTime > 0 && process->priority < highestPriority && process->arrivalTime <= currentTime) {
                highestPriority = process->priority;
                selectedProcessIndex = i;
            }

            i = (i + 1) % MAX_PROCESSES;
        }

        if (selectedProcessIndex != -1) {
            struct Process* process = &taskQueue->processes[selectedProcessIndex];
            int executionTime = min(process->remainingTime, timeQuantum);

            process->remainingTime -= executionTime;
            currentTime += executionTime;

            if (ganttIndex == 0 || strcmp(process->name, ganttChart[ganttIndex - 1].processName) != 0) {
                strcpy(ganttChart[ganttIndex].processName, process->name);
                ganttChart[ganttIndex].executionTime = executionTime;
                ganttIndex++;
            } else {
                ganttChart[ganttIndex - 1].executionTime += executionTime;
            }

            if (process->remainingTime == 0) {
                process->completionTime = currentTime;
                process->turnaroundTime = process->completionTime - process->arrivalTime;
                process->waitingTime = process->turnaroundTime - process->burstTime;
                completedProcesses++;
                printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", currentTime - ganttChart[ganttIndex - 1].executionTime, currentTime, process->name);
            }
        } else {
            currentTime++;
        }
    }

    printf("\nGantt Chart:\n");
    printf("-------------\n");
    printf("|");
    for (int i = 0; i < ganttIndex; i++) {
        printf(" %s |", ganttChart[i].processName);
    }
    printf("\n-------------\n");
    printf("0");
    int cumulativeTime = 0;
    for (int i = 0; i < ganttIndex; i++) {
        cumulativeTime += ganttChart[i].executionTime;
        printf("------%d", cumulativeTime);
    }
    printf("\n");
}


int main() {
    struct TaskQueue taskQueue;
    taskQueue.front = 0;
    taskQueue.rear = -1;
    taskQueue.size = 0;

    int option, timeQuantum;
    struct Process process;

    int processesAdded = 0;  // Flag to track if processes have been added

    do {
        printf("\nDynamic Scheduling Menu\n");
        printf("1. Add Process\n");
        printf("2. Remove Process\n");
        printf("3. Run SJF Scheduling\n");
        printf("4. Run Round Robin Scheduling\n");
        printf("5. Run Priority Scheduling\n");
        printf("6. Run FCFS Scheduling\n");
        printf("7. Print Process Table\n");
        printf("8. Print Metrics Table\n");
        printf("9. Generate Reports\n");
        printf("10. Exit\n");
        printf("Enter your option: ");
        scanf("%d", &option);


        char processName[20];
        switch (option) {
            case 1:
                // Add a process to the task queue

                printf("Enter process name: ");
                scanf("%s", processName);
                strcpy(process.name, processName);

                // Check for duplicate process names before completing the input
                for (int i = taskQueue.front; i <= taskQueue.rear; i++) {
                    if (strcmp(taskQueue.processes[i].name, process.name) == 0) {
                        printf("Error: Process with name '%s' already exists. Cannot add duplicate processes.\n", process.name);
                        process.name[0] = '\0';  // Clear the process name
                        break;
                    }
                }

                if (process.name[0] != '\0') {
                    printf("Enter arrival time: ");
                    scanf("%d", &process.arrivalTime);
                    printf("Enter burst time: ");
                    scanf("%d", &process.burstTime);
                    printf("Enter priority: ");
                    scanf("%d", &process.priority);
                    process.remainingTime = process.burstTime;
                    process.completionTime = 0;
                    process.turnaroundTime = 0;
                    process.waitingTime = 0;

                    enqueue(&taskQueue, process);
                    processesAdded = 1;  // Set the flag to indicate that processes have been added
                }

                break;
            case 2:
                // Remove a process from the task queue
                printf("\nEnter the name of the process to remove: ");
                scanf("%s", process.name);
                removeProcess(&taskQueue, process.name);
                break;
            case 3:
                if (processesAdded) {
                    sjfScheduling(&taskQueue);
                    printf("SJF Scheduling completed.\n");
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;
            case 4:
                if (processesAdded) {
                    printf("Enter the time quantum: ");
                    scanf("%d", &timeQuantum);
                    roundRobinScheduling(&taskQueue, timeQuantum);
                    printf("Round Robin Scheduling completed.\n");
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;
            case 5:
                if (processesAdded) {
                    prioritySchedulingWithPreemption(&taskQueue);
                    printf("Priority Scheduling completed.\n");
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;
            case 6:
                if (processesAdded) {
                    fcfsScheduling(&taskQueue);
                    printf("FCFS Scheduling completed.\n");
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;            
            case 7:
                if (processesAdded) {
                    printProcessTable(&taskQueue);
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;
            case 8:
                if (processesAdded) {
                    printMetricsTable(&taskQueue);
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;
            case 9:
                if (processesAdded) {
                    printf("\nEnter the time quantum for the Round Robin: ");
                    scanf("%d", &timeQuantum);
                    printf("*************************************** SJF Scheduling Performance Metrics ***********************************************\n");
                    sjfScheduling(&taskQueue);
                    printMetricsTable(&taskQueue);
                    resetTaskQueue(&taskQueue);

                    printf("\n*************************************** Round Robin Scheduling Performance Metrics ***********************************************\n");
                    roundRobinScheduling(&taskQueue, timeQuantum);
                    printMetricsTable(&taskQueue);
                    resetTaskQueue(&taskQueue);

                    printf("\n*************************************** Priority Scheduling Performance Metrics ***********************************************\n");
                     prioritySchedulingWithPreemption(&taskQueue);
                    printMetricsTable(&taskQueue);
                    resetTaskQueue(&taskQueue);
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;
            case 10:
                printf("Exiting the program.\n");
                break;
            default:
                printf("Invalid option. Please try again.\n");
        }
    } while (option != 10);

    return 0;
}
