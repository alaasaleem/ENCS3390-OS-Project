#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#define MAX_NAME_LENGTH 10
#define MAX_PROCESSES 100

// Structure to represent a process
struct Process {
    char name[MAX_NAME_LENGTH];
    int arrivalTime;
    int burstTime;
    int remainingTime;
    int completionTime;
    int turnaroundTime;
    int waitingTime;
    int priority;
};

// Structure to represent a task queue
struct TaskQueue {
    struct Process processes[MAX_PROCESSES];
    int front;
    int rear;
    int size;
};

int numOfAddedProcesses = 0;  

// Function prototypes
void enqueue(struct TaskQueue* queue, struct Process process);
struct Process dequeue(struct TaskQueue* queue);
int isQueueEmpty(struct TaskQueue* queue);
void sjfScheduling(struct TaskQueue* taskQueue);
void roundRobinScheduling(struct TaskQueue* taskQueue, int timeQuantum);
void prioritySchedulingNonPreemptive(struct TaskQueue* taskQueue);
void prioritySchedulingWithPreemption(struct TaskQueue* taskQueue);
void printProcessTable(struct TaskQueue* taskQueue);
void printMetricsTable(struct TaskQueue* taskQueue);
void removeProcess(struct TaskQueue* queue, char* processName);
void clearInputBuffer();
int min(int a, int b);

void removeProcess(struct TaskQueue* queue, char* processName) {
    int found = 0;

    for (int i = queue->front; i <= queue->rear; i++) {
        if (strcmp(queue->processes[i].name, processName) == 0) {
            found = 1;
            // Shift the remaining processes to the left
            for (int j = i; j < queue->rear; j++) {
                queue->processes[j] = queue->processes[j + 1];
            }
            queue->rear--;
            queue->size--;
            break;
        }
    }

    if (found) {
        printf("Process '%s' removed successfully.\n", processName);
    } else {
        printf("Process '%s' not found in the task queue.\n", processName);
    }
}
// Enqueues a process into the task queue
void enqueue(struct TaskQueue* queue, struct Process process) {
    if (queue->rear == MAX_PROCESSES - 1) {
        printf("Queue is full. Cannot enqueue more tasks.\n");
        return;
    }

    // Increase the rear index and add the process to the queue
    queue->rear++;
    queue->processes[queue->rear] = process;
    queue->size++;
}
// Dequeues a process from the task queue
struct Process dequeue(struct TaskQueue* queue) {
    if (isQueueEmpty(queue)) {
        // Return an empty process if the queue is empty
        struct Process emptyProcess;
        strcpy(emptyProcess.name, "");
        emptyProcess.arrivalTime = 0;
        emptyProcess.burstTime = 0;
        emptyProcess.remainingTime = 0;
        emptyProcess.completionTime = 0;
        emptyProcess.turnaroundTime = 0;
        emptyProcess.waitingTime = 0;
        emptyProcess.priority = 0;
        return emptyProcess;
    }

    // Retrieve the process at the front of the queue
    struct Process dequeuedProcess = queue->processes[queue->front];

    // Increase the front index and decrease the queue size
    queue->front++;
    queue->size--;

    if (queue->size == 0) {
        // Reset the queue indices if the queue becomes empty
        queue->front = 0;
        queue->rear = -1;
    }

    return dequeuedProcess;
}
// Checks if the task queue is empty
int isQueueEmpty(struct TaskQueue* queue) {
    return (queue->size == 0);
}
// Finds the minimum of two numbers
int min(int a, int b) {
    return (a < b) ? a : b;
}

// Performs round-robin scheduling on the task queue with a given time quantum
void roundRobinScheduling(struct TaskQueue* taskQueue, int timeQuantum) {
    int currentTime = 0;
    int completedProcesses = 0;

    // Create a Gantt chart array to store process names and corresponding execution times
    struct GanttEntry {
        char processName[10];
        int executionTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES * 100];  // Assuming maximum 100 time slots per process

    int ganttIndex = 0;  // Index to keep track of the Gantt chart entries

    while (completedProcesses < taskQueue->size) {
        int i = taskQueue->front;

        while (i <= taskQueue->rear) {
            struct Process* process = &taskQueue->processes[i];

            if (process->remainingTime > 0) {
                int executionTime = (process->remainingTime > timeQuantum) ? timeQuantum : process->remainingTime;

                process->remainingTime -= executionTime;
                currentTime += executionTime;

                // Store the Gantt chart entry
                strcpy(ganttChart[ganttIndex].processName, process->name);
                ganttChart[ganttIndex].executionTime = executionTime;
                ganttIndex++;
                
                
                // Print the execution order
                if (process->arrivalTime <= currentTime - executionTime) {
                    if (process->remainingTime == 0) {
                        printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", currentTime - executionTime, currentTime, process->name);
                    } else {
                        printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", currentTime - executionTime, currentTime, process->name, process->remainingTime);
                    }
                }

                if (process->remainingTime == 0) {
                    // Process completed
                    process->completionTime = currentTime;
                    process->turnaroundTime = process->completionTime - process->arrivalTime;
                    process->waitingTime = process->turnaroundTime - process->burstTime;
                    completedProcesses++;
                }
            }

            i = (i + 1) % MAX_PROCESSES;  // Circularly traverse the queue
        }
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------------------------------------------------------------------\n");
    for (int i = 0; i < ganttIndex; i++) {
        printf("| %s ", ganttChart[i].processName);
    }
    printf("|\n");
    printf("----------------------------------------------------------------------\n");
    printf("0");
    int cumulativeTime = 0;
    for (int i = 0; i < ganttIndex; i++) {
        cumulativeTime += ganttChart[i].executionTime;
        printf("------%d", cumulativeTime);
    }
    printf("\n");
    
    // Print the process table and metrics table
    printProcessTable(taskQueue);
    float totalWaitingTime = 0;
    float totalTurnaroundTime = 0;

    printf("\nMetrics Table:\n");

}


// Performs FCFS scheduling on the task queue
void fcfsScheduling(struct TaskQueue* taskQueue) {
    int currentTime = 0;
    int completedProcesses = 0;

    // Create a Gantt chart array to store process names and corresponding execution times
    struct GanttEntry {
        char processName[10];
        int executionTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES * 100];  // Assuming maximum 100 time slots per process

    int ganttIndex = 0;  // Index to keep track of the Gantt chart entries

    // Print processes with arrival time
    printf("\nProcess %s (Arrival Time: %d)\n", taskQueue->processes[taskQueue->front].name, taskQueue->processes[taskQueue->front].arrivalTime);
    for (int i = taskQueue->front + 1; i <= taskQueue->rear; i++) {
        printf("Process %s (Arrival Time: %d)\n", taskQueue->processes[i].name, taskQueue->processes[i].arrivalTime);
        printf("\n");
    }
    
    printf("The order in which processes or threads are selected for execution:\n");
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];

        // Calculate waiting time
        process->waitingTime = currentTime - process->arrivalTime;
        if (process->waitingTime < 0)
            process->waitingTime = 0;

        // Calculate completion time and turnaround time
        process->completionTime = currentTime + process->burstTime;
        process->turnaroundTime = process->completionTime - process->arrivalTime;

        currentTime = process->completionTime;

        // Print the execution order
        if (process->burstTime == 0) {
            printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", currentTime - process->burstTime, currentTime, process->name);
        } else {
            printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", currentTime - process->burstTime, currentTime, process->name, process->burstTime);
        }
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("-------------\n");
    for (int i = 0; i < ganttIndex; i++) {
        printf("| %s ", ganttChart[i].processName);
    }
    printf("|\n");
    printf("-------------\n");
    printf("0");
    int cumulativeTime = 0;
    for (int i = 0; i < ganttIndex; i++) {
        cumulativeTime += ganttChart[i].executionTime;
        printf("------%d", cumulativeTime);
    }
    printf("\n");
    // Print the process table and metrics table
    printProcessTable(taskQueue);
    printMetricsTable(taskQueue);

}

// Performs SJF scheduling on the task queue
void sjfScheduling(struct TaskQueue* taskQueue) {
    // Sort the tasks based on burst time using bubble sort
    for (int i = 0; i < taskQueue->size - 1; i++) {
        for (int j = 0; j < taskQueue->size - i - 1; j++) {
            if (taskQueue->processes[j].burstTime > taskQueue->processes[j + 1].burstTime) {
                // Swap the processes if the current process has higher burst time than the next process
                struct Process temp = taskQueue->processes[j];
                taskQueue->processes[j] = taskQueue->processes[j + 1];
                taskQueue->processes[j + 1] = temp;
            }
        }
    }

    int currentTime = 0;

    printf("The order in which processes or threads are selected for execution:\n");
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];

        // Calculate waiting time
        process->waitingTime = currentTime - process->arrivalTime;
        if (process->waitingTime < 0)
            process->waitingTime = 0;

        // Calculate completion time and turnaround time
        process->completionTime = currentTime + process->burstTime;
        process->turnaroundTime = process->completionTime - process->arrivalTime;

        currentTime = process->completionTime;

        // Print the execution order
        if (process->burstTime == 0) {
            printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", currentTime - process->burstTime, currentTime, process->name);
        } else {
            printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", currentTime - process->burstTime, currentTime, process->name, process->burstTime);
        }
    }

    // Print the process details
    printf("\nProcess Details:\n");
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process process = taskQueue->processes[i];
        printf("Process %s (Arrival Time: %d)\n", process.name, process.arrivalTime);
    }

    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("---------");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("--------");
    }
    printf("\n|");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("   %s    |", taskQueue->processes[i].name);
    }
    printf("\n---------");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("--------");
    }
    printf("\n0");
    for (int i = 0; i < taskQueue->size; i++) {
        printf("--------%d", taskQueue->processes[i].completionTime);
    }
    printf("\n");
    // Print the process table and metrics table
    printProcessTable(taskQueue);
    printMetricsTable(taskQueue);
}

// Helper function to reset the task queue
void resetTaskQueue(struct TaskQueue* taskQueue) {
    taskQueue->front = 0;
    taskQueue->rear = -1;
    taskQueue->size = 0;
}
// Prints the process table
void printProcessTable(struct TaskQueue* taskQueue) {
    printf("\nProcess Table:\n");
    printf("+-------+-----------------+------------------+--------------+\n");
    printf("| Name  | Arrival Time    | Burst Time       | Priority     |\n");
    printf("|       |                 |                  |              |\n");
    printf("+-------+-----------------+------------------+--------------+\n");

    for (int i = taskQueue->front; i <= taskQueue->rear; i++) {
        printf("| %-5s | %-15d | %-16d | %-12d |\n",
               taskQueue->processes[i].name, taskQueue->processes[i].arrivalTime,
               taskQueue->processes[i].burstTime, taskQueue->processes[i].priority);
    }

    printf("+-------+-----------------+------------------+--------------+\n");
}

// Helper function to calculate and print the metrics table
void printMetricsTable(struct TaskQueue* taskQueue) {
        float totalWaitingTime = 0;
    float totalTurnaroundTime = 0;

    printf("\nMetrics Table:\n");
    printf("--------------------------------------------------------------\n");
    printf("| Process | Completion Time | Turnaround Time | Waiting Time |\n");
    printf("--------------------------------------------------------------\n");

    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];

        totalWaitingTime += process->waitingTime;
        totalTurnaroundTime += process->turnaroundTime;
 
        printf("| %s      |         %d       |        %d         |        %d    |\n",
               process->name, process->completionTime, process->turnaroundTime, process->waitingTime);
    }

    printf("-----------------------------------------------------------------------------------------------------\n");
    printf("  AWT = %.2f\n", totalWaitingTime / taskQueue->size);
    printf("  TAT = %.2f\n", totalTurnaroundTime / taskQueue->size);
    printf("-----------------------------------------------------------------------------------------------------\n");
}


// Performs priority scheduling on the task queue with preemption
void prioritySchedulingWithPreemption(struct TaskQueue* taskQueue) {
    int currentTime = 0;
    int completedProcesses = 0;
    int timeQuantum = 1;

    struct GanttEntry {
        char processName[10];
        int executionTime;
    };
    struct GanttEntry ganttChart[MAX_PROCESSES];

    int ganttIndex = 0;

    printf("\nProcess %s (Arrival Time: %d)\n", taskQueue->processes[taskQueue->front].name, taskQueue->processes[taskQueue->front].arrivalTime);
    for (int i = taskQueue->front + 1; i <= taskQueue->rear; i++) {
        printf("Process %s (Arrival Time: %d)\n", taskQueue->processes[i].name, taskQueue->processes[i].arrivalTime);
        printf("\n");
    }
    printf("\nThe order in which processes or threads are selected for execution:\n");

    while (completedProcesses < taskQueue->size) {
        int i = taskQueue->front;
        int highestPriority = INT_MAX;
        int selectedProcessIndex = -1;

        while (i <= taskQueue->rear) {
            struct Process* process = &taskQueue->processes[i];

            if (process->remainingTime > 0 && process->priority < highestPriority && process->arrivalTime <= currentTime) {
                highestPriority = process->priority;
                selectedProcessIndex = i;
            }

            i = (i + 1) % MAX_PROCESSES;
        }

        if (selectedProcessIndex != -1) {
            struct Process* process = &taskQueue->processes[selectedProcessIndex];
            int executionTime = min(process->remainingTime, timeQuantum);

            process->remainingTime -= executionTime;
            currentTime += executionTime;

            if (ganttIndex == 0 || strcmp(process->name, ganttChart[ganttIndex - 1].processName) != 0) {
                strcpy(ganttChart[ganttIndex].processName, process->name);
                ganttChart[ganttIndex].executionTime = executionTime;
                ganttIndex++;
            } else {
                ganttChart[ganttIndex - 1].executionTime += executionTime;
            }

            if (process->remainingTime == 0) {
                process->completionTime = currentTime;
                process->turnaroundTime = process->completionTime - process->arrivalTime;
                process->waitingTime = process->turnaroundTime - process->burstTime;
                completedProcesses++;
                printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", currentTime - ganttChart[ganttIndex - 1].executionTime, currentTime, process->name);
            }
        } else {
            currentTime++;
        }
    }

    printf("\nGantt Chart:\n");
    printf("-------------\n");
    printf("|");
    for (int i = 0; i < ganttIndex; i++) {
        printf(" %s |", ganttChart[i].processName);
    }
    printf("\n-------------\n");
    printf("0");
    int cumulativeTime = 0;
    for (int i = 0; i < ganttIndex; i++) {
        cumulativeTime += ganttChart[i].executionTime;
        printf("------%d", cumulativeTime);
    }
    printf("\n");
    // Print the process table and metrics table
    printProcessTable(taskQueue);
    printMetricsTable(taskQueue);

}

void prioritySchedulingNonPreemptive(struct TaskQueue* taskQueue) {
    // Sort the tasks based on priority using bubble sort
    for (int i = 0; i < taskQueue->size - 1; i++) {
        for (int j = 0; j < taskQueue->size - i - 1; j++) {
            if (taskQueue->processes[j].priority > taskQueue->processes[j + 1].priority) {
                // Swap the processes if the current process has higher priority than the next process
                struct Process temp = taskQueue->processes[j];
                taskQueue->processes[j] = taskQueue->processes[j + 1];
                taskQueue->processes[j + 1] = temp;
            } else if (taskQueue->processes[j].priority == taskQueue->processes[j + 1].priority) {
                // If two processes have equal priority, the one with a lower arrival time should have higher priority
                if (taskQueue->processes[j].arrivalTime > taskQueue->processes[j + 1].arrivalTime) {
                    struct Process temp = taskQueue->processes[j];
                    taskQueue->processes[j] = taskQueue->processes[j + 1];
                    taskQueue->processes[j + 1] = temp;
                }
            }
        }
    }

   int currentTime = 0;

    printf("The order in which processes or threads are selected for execution:\n");
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];

        // Calculate waiting time
        process->waitingTime = currentTime - process->arrivalTime;
        if (process->waitingTime < 0)
            process->waitingTime = 0;

        // Calculate completion time and turnaround time
        process->completionTime = currentTime + process->burstTime;
        process->turnaroundTime = process->completionTime - process->arrivalTime;

        currentTime = process->completionTime;

        // Print the execution order
        if (process->burstTime == 0) {
            printf("From \"%d\" to \"%d\": \"%s\" (Completed)\n", currentTime - process->burstTime, currentTime, process->name);
        } else {
            printf("From \"%d\" to \"%d\": \"%s\" (%d time units left)\n", currentTime - process->burstTime, currentTime, process->name, process->burstTime);
        }
    }
    // Print the Gantt chart
    printf("\nGantt Chart:\n");
    printf("-----------------------------------------\n");
    printf("| ");
    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];
        printf("%s\t| ", process->name);
    }
    printf("\n");
    printf("-----------------------------------------\n");

    for (int i = 0; i < taskQueue->size; i++) {
        struct Process* process = &taskQueue->processes[i];
        printf("%d", process->completionTime - process->burstTime);

        for (int j = 0; j < strlen(process->name) + 1; j++) {
            printf(" ");
        }

        if (i == taskQueue->size - 1) {
            printf("%d", process->completionTime);
        }

        printf("\t");
    }
    printf("\n");
    // Print the process table and metrics table
    printProcessTable(taskQueue);
    printMetricsTable(taskQueue);
}


void clearInputBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        // Discard characters until a newline or EOF is encountered
    }
}


int main() {
    struct TaskQueue taskQueue;
    taskQueue.front = 0;
    taskQueue.rear = -1;
    taskQueue.size = 0;

    int option, timeQuantum;
    struct Process process;

    

    do {
        printf("\nDynamic Scheduling Menu\n");
        printf("1. Add Process\n");
        printf("2. Remove Process\n");
        printf("3. Run SJF Scheduling\n");
        printf("4. Run Round Robin Scheduling\n");
        printf("5. Run Priority Scheduling\n");
        printf("6. Run FCFS Scheduling\n");
        printf("7. Exit\n");
        printf("Enter your option: ");
        scanf("%d", &option);


        char processName[20];
        switch (option) {
            case 1:
                // Add a process to the task queue
                printf("Enter process name: ");
                scanf("%s", processName);
                strcpy(process.name, processName);

                // Check for duplicate process names before completing the input
                for (int i = taskQueue.front; i <= taskQueue.rear; i++) {
                    if (strcmp(taskQueue.processes[i].name, process.name) == 0) {
                        printf("Error: Process with name '%s' already exists. Cannot add duplicate processes.\n", process.name);
                        process.name[0] = '\0';  // Clear the process name
                        break;
                    }
                }

                if (process.name[0] > '\0') {
                    int validInput = 0; // Flag to track valid input

                    while (!validInput) {
                        printf("Enter arrival time: ");
                        if (scanf("%d", &process.arrivalTime) != 1) {
                            printf("Invalid input for arrival time. Please enter an integer.\n");
                            clearInputBuffer();
                            continue;
                        }

                        printf("Enter burst time: ");
                        if (scanf("%d", &process.burstTime) != 1) {
                            printf("Invalid input for burst time. Please enter an integer.\n");
                            clearInputBuffer();
                            continue;
                        }

                        printf("Enter priority: ");
                        if (scanf("%d", &process.priority) != 1) {
                            printf("Invalid input for priority. Please enter an integer.\n");
                            clearInputBuffer();
                            continue;
                        }

                        validInput = 1;
                    }

                    process.remainingTime = process.burstTime;
                    process.completionTime = 0;
                    process.turnaroundTime = 0;
                    process.waitingTime = 0;

                    enqueue(&taskQueue, process);
                    numOfAddedProcesses += 1;
                }
                break;

            case 2:
                if (numOfAddedProcesses > 0){
                    // Remove a process from the task queue
                    printf("\nEnter the name of the process to remove: ");
                    scanf("%s", process.name);
                    removeProcess(&taskQueue, process.name);
                    numOfAddedProcesses -= 1; 
                }
                else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;
            case 3:
                if (numOfAddedProcesses > 0){
                    sjfScheduling(&taskQueue);
                    printf("SJF Scheduling completed.\n");
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;
            case 4:
                if (numOfAddedProcesses > 0){
                    printf("Enter the time quantum: ");
                    scanf("%d", &timeQuantum);
                    roundRobinScheduling(&taskQueue, timeQuantum);
                    printf("Round Robin Scheduling completed.\n");
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;
            case 5:
                if (numOfAddedProcesses > 0){
                    prioritySchedulingNonPreemptive(&taskQueue);
                    printf("Priority Scheduling completed.\n");
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;
            case 6:
                if (numOfAddedProcesses > 0){
                    fcfsScheduling(&taskQueue);
                    printf("FCFS Scheduling completed.\n");
                } else {
                    printf("No processes added. Please add processes first.\n");
                }
                break;            
            case 7:
                printf("Exiting the program.\n");
                break;
            default:
                printf("Invalid option. Please try again.\n");
        }
    } while (option != 7);

    return 0;
}
